#!/usr/bin/perl

# This script compares perfSONAR data collected in central repositories to that
# found in the original sources (perfSONAR hosts) and reports any observed
# discrepancies and errors encountered.

# For more information, use the --help option or see the README.md file under
# https://github.com/opensciencegrid/perfSONAR-verify/
 
use strict;
use warnings;

use DateTime;
use Time::Local;
use Getopt::Long qw(:config bundling);
use FindBin qw($Bin $Script);
use IO::File;
use URI::Escape;
use JSON;
use Carp;
use Data::Dumper;

use lib '/opt/perfsonar_ps/toolkit/lib/';
use perfSONAR_PS::Client::Esmond::ApiFilters;
use perfSONAR_PS::Client::Esmond::ApiConnect;

$|=1;

$ENV{TZ}   = 'UTC';

# Read the config values
my $conf_file = "$Bin/../conf/verify.conf";
my %config = read_conf($conf_file);

# Config variables
my $DATA=$config{DATA};
my $LOGS=$config{LOGS};
my $MESHES=$config{MESHES};
my $NODES=$config{NODES};
my $FAILURES_RRANGE=$config{FAILURES_RRANGE};
my $FAILURES_WINDOW=$config{FAILURES_WINDOW};
my $HISTOGRAM_OWDELAY_RRANGE=$config{HISTOGRAM_OWDELAY_RRANGE};
my $HISTOGRAM_OWDELAY_WINDOW=$config{HISTOGRAM_OWDELAY_WINDOW};
my $HISTOGRAM_TTL_RRANGE=$config{HISTOGRAM_TTL_RRANGE};
my $HISTOGRAM_TTL_WINDOW=$config{HISTOGRAM_TTL_WINDOW};
my $PACKET_COUNT_LOST_RRANGE=$config{PACKET_COUNT_LOST_RRANGE};
my $PACKET_COUNT_LOST_WINDOW=$config{PACKET_COUNT_LOST_WINDOW};
my $PACKET_COUNT_SENT_RRANGE=$config{PACKET_COUNT_SENT_RRANGE};
my $PACKET_COUNT_SENT_WINDOW=$config{PACKET_COUNT_SENT_WINDOW};
my $PACKET_LOSS_RATE_RRANGE=$config{PACKET_LOSS_RATE_RRANGE};
my $PACKET_LOSS_RATE_WINDOW=$config{PACKET_LOSS_RATE_WINDOW};
my $PACKET_RETRANSMITS_RRANGE=$config{PACKET_RETRANSMITS_RRANGE};
my $PACKET_RETRANSMITS_WINDOW=$config{PACKET_RETRANSMITS_WINDOW};
my $PACKET_RETRANSMITS_SUBINTERVALS_RRANGE=$config{PACKET_RETRANSMITS_SUBINTERVALS_RRANGE};
my $PACKET_RETRANSMITS_SUBINTERVALS_WINDOW=$config{PACKET_RETRANSMITS_SUBINTERVALS_WINDOW};
my $PACKET_TRACE_RRANGE=$config{PACKET_TRACE_RRANGE};
my $PACKET_TRACE_WINDOW=$config{PACKET_TRACE_WINDOW};
my $THROUGHPUT_RRANGE=$config{THROUGHPUT_RRANGE};
my $THROUGHPUT_WINDOW=$config{THROUGHPUT_WINDOW};
my $THROUGHPUT_SUBINTERVALS_RRANGE=$config{THROUGHPUT_SUBINTERVALS_RRANGE};
my $THROUGHPUT_SUBINTERVALS_WINDOW=$config{THROUGHPUT_SUBINTERVALS_WINDOW};
my $TIMEOUT=$config{TIMEOUT};
my $VERBOSE=$config{VERBOSE};
my $DELAY=$config{DELAY};
my $CENTRAL_STORES=$config{CENTRAL_STORES};

# Convert relative to full paths
$DATA = "$Bin/../$DATA";
$LOGS = "$Bin/../$LOGS";

my $VERSION = '1.6';

my $date=undef;
my $fh=undef;

my %opt=();
GetOptions( \%opt,
            "display=s",     # validate (does alteration & validation),
                             # cover (does alteration & coverage),
                             # default: all (does alteration, validation, & coverage)
            "central=s",     # central data store
            "test=s",        # test (e.g., throughput, histogram-owdelay)
            "test_menu",     # provides a list of all tests from which to select
            "mesh=s",        # mesh name
            "mesh_menu",     # provides a list of all meshes from which to select
            "n=i",           # number of nodes to test
            "nodes=s",       # comma separated list of monitoring nodes
            "start=i",       # UNIX start time
            "start_date=s",  # start time with format: MM/DD/YY[YY][,hh[:mm:ss]]
            "end=i",         # UNIX end time
            "end_date=s",    # end time with format: MM/DD/YY[YY][,hh[:mm:ss]]
            "last=s",        # designates the last so many time units as the start time
            "delay=i",       # return only records older than this many seconds
            "out=s",         # output raw data. See help.
            "split_logs",    # log results to their respective test-type/central-store logs
            "update",        # force update of mesh-host information
            "debug",
            "help"
           );

if ( $opt{help} ) {
    help();
    exit(0);
}

# allow user override of delay
$DELAY = $opt{delay} if ( $opt{delay} );

# identify all central hosts and ports to use
my %ch_port=();
if (!defined $opt{central}) {
    print "Specify for --central a comma-separated list of central data store DNS names or IP addresses\n";
    print "follwed by an optional port number if not default port 80. Or use 'all' to query all stores.\n";
    exit(1);
}
if ( $opt{central} eq 'all' ) {
    my @ch = split(',', $CENTRAL_STORES);
    foreach my $h (@ch) {
        my ( $host, $port ) = split(':',$h);
        if ( $port ) {
            $ch_port{$host} = $port;
        } else {
            $ch_port{$host} = 80;
        }
    }
} elsif ( $opt{central} ){
    my $ch_list = $opt{central};
    my @ch = split(',', $ch_list);
    foreach my $h (@ch) {
        my ( $host, $port ) = split(':',$h);
        if ( $port ) {
            $ch_port{$host} = $port;
        } else {
            $ch_port{$host} = 80;
        }
    }
} else {
    print "Specify for --central a comma-separated list of central data store DNS names or IP addresses\n";
    print "follwed by an optional port number if not default port 80. Or use 'all' to query all stores.\n";
    exit(1);
}

my $display = $opt{display} || 'all';
if ( $display ne 'all' &&
     $display ne 'validate' &&
     $display ne 'cover' ) {
    print "Specify for --display 'validate', 'cover', 'all'; or simply exclude the option, which gets all.\n";
    exit(1);
}

my $test_selection=undef;
if ( !$opt{test} && !$opt{test_menu} ) { # Clean up logic if there is time
    print "Specify a test type (e.g., histogram-owdelay) with the --test option\n";
    print "Or use --test_menu to see a list of available test types.\n";
    exit(1);
} elsif ( $opt{test_menu}  ) {
    $test_selection = get_tests();
} elsif ( $opt{test} ne 'failures'                        &&
          $opt{test} ne 'histogram-owdelay'               && $opt{test} ne 'histogram-ttl'      &&
          $opt{test} ne 'packet-count-lost'               && $opt{test} ne 'packet-count-sent'  &&
          $opt{test} ne 'packet-loss-rate'                && $opt{test} ne 'packet-retransmits' &&
          $opt{test} ne 'packet-retransmits-subintervals' && $opt{test} ne 'packet-trace'       &&
          $opt{test} ne 'throughput'                      && $opt{test} ne 'throughput-subintervals' ) {
    print "Test '$opt{test}' is not supported.\n";
    print "Use --test_menu to see a list of available tests.\n";
    exit(1);
} elsif ( $opt{test} ) {
    $test_selection = $opt{test};
}

if ( !$opt{n} && !$opt{nodes} ) {
    print "   Specify a number of perfSONAR hosts to check with the --n option.\n";
    print "   Otherwise, specify a comma-separated list of host names (or IP addresses) with the --nodes option.\n";
    exit(1);
}


# Update mesh data if missing or requested
if ( !(-f "$DATA/$MESHES") || $opt{update} ) {
    $date = gmtime();
    print "[$date] Updating mesh and node information. This may take several minutes...\n";
    open($fh, '>', "$DATA/$MESHES");
    `$Bin/update_meshes`;
    `$Bin/update_nodes`;
    print "[$date] Updated mesh and node information. Continuing...\n";
}

my $output=undef;          # the script's output buffer
my $node_ip_ref = get_node_ips("$DATA/$NODES");
my %mesh_ips=();
my $mesh_selection=undef;  # the selected mesh name
my %mesh_menu=();
my $mesh_ref = get_nodes_by_mesh();
if ( $opt{mesh_menu} ) {
    $mesh_selection = mesh_menu($mesh_ref);
} elsif ( $opt{mesh} ) {
    $mesh_selection = $opt{mesh};
}


our $terminator= "$Bin/terminator"; # script to kill a given process on timeout

my $timeout = 0;
my $rrange=undef;
my $window=undef;
if ( $test_selection eq 'failures' ) {  # Again, clean up logic
    $rrange = $FAILURES_RRANGE;
    $window = $FAILURES_WINDOW;
} elsif ( $test_selection eq 'histogram-owdelay' ) {
    $rrange = $HISTOGRAM_OWDELAY_RRANGE;
    $window = $HISTOGRAM_OWDELAY_WINDOW;
} elsif ( $test_selection eq 'histogram-ttl' ) {
    $rrange = $HISTOGRAM_TTL_RRANGE;
    $window = $HISTOGRAM_TTL_WINDOW;
} elsif ( $test_selection eq 'packet-count-lost' ) {
    $rrange = $PACKET_COUNT_LOST_RRANGE;
    $window = $PACKET_COUNT_LOST_WINDOW;
} elsif ( $test_selection eq 'packet-count-sent' ) {
    $rrange = $PACKET_COUNT_SENT_RRANGE;
    $window = $PACKET_COUNT_SENT_WINDOW;
} elsif ( $test_selection eq 'packet-loss-rate' ) {
    $rrange = $PACKET_LOSS_RATE_RRANGE;
    $window = $PACKET_LOSS_RATE_WINDOW;
} elsif ( $test_selection eq 'packet-retransmits' ) {
    $rrange = $PACKET_RETRANSMITS_RRANGE;
    $window = $PACKET_RETRANSMITS_WINDOW;
} elsif ( $test_selection eq 'packet-retransmits-subintervals' ) {
    $rrange = $PACKET_RETRANSMITS_SUBINTERVALS_RRANGE;
    $window = $PACKET_RETRANSMITS_SUBINTERVALS_WINDOW;
} elsif ( $test_selection eq 'packet-trace' ) {
    $rrange = $PACKET_TRACE_RRANGE;
    $window = $PACKET_TRACE_WINDOW;
} elsif ( $test_selection eq 'throughput' ) {
    $rrange = $THROUGHPUT_RRANGE;
    $window = $THROUGHPUT_WINDOW;
} elsif ( $test_selection eq 'throughput-subintervals' ) {
    $rrange = $THROUGHPUT_SUBINTERVALS_RRANGE;
    $window = $THROUGHPUT_SUBINTERVALS_WINDOW;
}

my $now   = time();
my $start = undef;
my $end   = undef;
my $last  = undef;
my $start_date=undef;
my $end_date=undef;
if ( $opt{start} && $opt{end} ) {
    $start = $opt{start};
    $end   = $opt{end};
} elsif ( $opt{start_date} && $opt{end_date}  ) {
    $start = date2sec($opt{start_date});
    $end   = date2sec($opt{end_date});
} elsif ( $opt{last} ) {
    $last = $opt{last};
    $last = lc( $last );
    $end  = $now - $DELAY;
    $start = get_start_secs( $last,$end );
} else {   # select "random" start time
    $end   = $now - $DELAY;
    $start = set_start_time($rrange,$window,$end);
}


# Node selection process
$date = gmtime();
my $node_counts = undef;
my $total_nodes = undef;
my $node_list = undef;
my @test_nodes  = ();
my $test_nodes_ref = undef;
my $test_ip_ref = undef;

if ( $mesh_selection ) {   # Note: nodes not in the selected mesh are ignored
   ($node_counts,$test_nodes_ref,$test_ip_ref) =
        get_mesh_nodes($mesh_ref,$opt{test},$mesh_selection,$opt{n},$opt{nodes},$start,$end); 
    $output .= "$node_counts\n";
    $total_nodes = scalar (@{$test_nodes_ref});
    foreach my $node (@{$test_nodes_ref}) {
        $output .= "$node (" . $$test_ip_ref{$node} . ")\n";
    }
    $node_list = join( ',', @{$test_nodes_ref} );
} elsif ( $opt{nodes} ) {  # Note: With the --nodes option, ignore --n
    @test_nodes = split(',', $opt{nodes});
    $total_nodes = scalar (@test_nodes);
    $node_list = $opt{nodes};
    $test_nodes_ref = \@test_nodes;
} else {                   # Obtain list of nodes to test from Esmond central data store
    ($node_counts,$test_nodes_ref,$test_ip_ref) = get_nodes($opt{test},$opt{n},$start,$end);
    $output .= "$node_counts\n";
    $total_nodes = scalar (@{$test_nodes_ref});
    foreach my $node (@{$test_nodes_ref}) {
        $output .= "$node (" . $$test_ip_ref{$node} . ")\n";
    }
    $node_list = join( ',', @{$test_nodes_ref} );
}

# -----------------------------------------------------------------------------
# remote data collection

my $remote_output=undef;
$remote_output .= "\n\n__________\n\n";
$remote_output .= "Obtaining data directly from perfSONAR nodes...\n";
my %accepted_nodes=();
my %remote_nodes=();
my @remote=();
my @all_remote=();
foreach my $node (@{$test_nodes_ref}) {
    # Get data from the remote node
    my $res=undef;
    my @args=();
       push @args, $test_selection;
       push @args, $node;
       push @args, $start;
       push @args, $end;
       push @args, $node;
       push @args, 80;    # Remote perfSONAR hosts always use port 80
    ($res,@remote) = call_with_timeout('Remote',\&gd,\@args,$TIMEOUT,$VERBOSE,'USR2');

    # Exclude from comparison nodes that are unreachable or have timed out
    if ( !defined $remote[0] ) {
        $remote_output .= "Remote node $node rejected. Cause:\n";
        $remote_output .= "    No data available.\n";
    } elsif ( $remote[0] !~ m/Error/ && $res == 1 ) {
        $remote_output .= "\nRemote node $node accepted\n\n";
        $accepted_nodes{$node} = 1;
        push @{ $remote_nodes{$node} }, @remote;
    } elsif ( $res == 0 ) {
        $remote_output .= "\nRemote node $node rejected.\n";
        $remote_output .= "    Cause: $remote[0]\n\n";
    } else {
        $remote_output .= "\nRemote node $node rejected.\n";
        $remote_output .= "    Cause: $remote[0]\n\n";
    }
}

# Gather remote data to be compared
foreach my $node (keys %accepted_nodes) {
 push @all_remote,  @{ $remote_nodes{$node} } if ( defined $remote_nodes{$node} );
}
my $all_remote_size = scalar @all_remote;

if ( $opt{out} ) {
    my $fh;
    my $file_name = $opt{out} . '-' . $now . '.remote';
    open($fh, '>', "$file_name");
    foreach my $rec (@all_remote) {
        print $fh "$rec\n";
    }
    close $fh;
}


# -----------------------------------------------------------------------------

# central data collection

my $logtime=undef;
my $ds=undef;
my $ds_short=undef;
my $port=undef;
foreach $ds (sort keys %ch_port) {
    $port = $ch_port{$ds};
    my @p = split('\.',$ds);
    $ds_short = $p[0];

    $logtime = gmtime();
    $output  = "\n\n__________________________________________________________\n\n";
    $output .= "Started script (pid $$) at:   $logtime UTC\n";
    $output .= "\nInitiating a sample comparison between $test_selection archives in the\n";
    $output .= "Esmond data store ($ds:$port) and remote perfSONAR nodes.\n";
    $output .= "Selected UTC start time: " . sec2date( $start ) . " (UNIX time: $start)\n";
    $output .= "Selected UTC end   time: " . sec2date( $end ) . " (UNIX time: $end)\n";
    $output .= "Selected mesh: $mesh_selection\n" if ( $mesh_selection );

    $output .= "\nExecuting:\n";
    if ( $opt{mesh_menu} || $opt{mesh} ) {
        my $command =
           "./$Script --central $ds:$port --mesh '$mesh_selection' --test $test_selection --nodes $node_list --start $start --end $end --display $display\n";
        $output .= $command;
    } else {
        my $command =
           "./$Script --central $ds:$port --test $test_selection --nodes $node_list --start $start --end $end --display $display\n";
        $output .= $command;
    }

    $date = gmtime();
    $output .= "\n[$date] Obtaining data from Esmond central data store...\n";
    my %central_nodes=();
    my @central=();
    my @all_central=();
    foreach my $node (@{$test_nodes_ref}) {
        # Get data related to the node
        my $res=undef;
        my @args=();
           push @args, $test_selection;
           push @args, $node;
           push @args, $start;
           push @args, $end;
           push @args, $ds;
           push @args, $port;
        ($res,@central) = call_with_timeout('Central',\&gd,\@args,$TIMEOUT,$VERBOSE,'USR2');
        if ( !defined $central[0] ) {
            $output .= "Node $node rejected. Cause:\n";
            $output .= "    No data in central store.\n";
        } elsif ( $central[0] !~ m/Error/  && $res == 1 ) {  # node accepted for comparison
            push @{ $central_nodes{$node} }, @central;
        } elsif ( $res == 1 ) {
            $output .= "Data in central store $ds:$port for $node rejected.\n";
            $output .= "    Cause: $central[0]\n";
            $timeout = 0;
        } else {
            $output .= "Data from central store $ds:$port unavailable. No comparisons possible at this time.\n";
            $output .= "    Cause: $central[0]\n";
            end();
        }
    }

    my $count = keys %central_nodes;
    if ( $count == 0 ) {
        $output .= "Data from central store $ds:$port unavailable. No comparisons possible at this time.\n";
        $output .= "    Cause: Data gathering timed out\n";
        end();
    }

    # -----------------------------------------------------------------------------
    $output .= $remote_output;


    # Gather central data to be compared
    foreach my $node (keys %accepted_nodes) {
        push @all_central, @{ $central_nodes{$node} } if ( defined $central_nodes{$node} );
    }
    my $all_central_size = scalar @all_central;


    $output .= "\nComparing $all_central_size records from the central store to $all_remote_size records from perfSONAR hosts\n";

    if ( $opt{out} ) {
        my $fh;
        my $file_name = $opt{out} . '-' . $ds_short . '-' . $now . '.central';
        open($fh, '>', "$file_name");
        foreach my $rec (@all_central) {
            print $fh "$rec\n";
        }
        close $fh;
    }

    $output .= "checking for discrepancies...\n";
    threewaycompare(\@all_central,\@all_remote,$display,$opt{out},$ds_short);

    end();

    gen_links(\$output,$test_selection,$ds_short,$ds,$port);
}

# ---


sub read_conf {
    my $conf_file = shift;

    my $ch=undef;
    my %config=();
    open( $ch, '<', $conf_file ) or die "(pid $$) - Could not open configuration file '$conf_file'.\n";
    while (<$ch>) {
        next if ( $_ =~ m/^#/ );
        chomp $_;
        if ( $_ =~ m/=/ ) {
            my ($param,$value) = split('=', $_);
            my $junk;
            ($value,$junk) = split('#', $value); # ignore inline comments
            $param =~ s/^\s+|\s+$//g;            # do left/right space trim
            $value =~ s/^\s+|\s+$//g;
            $config{$param} = $value;
        }
    }
    close $ch;
    return %config;
}


# Execute a function call, but abort it if it takes too long to complete. If a
# signal other than the default ALRM is given, assume that the function being
# called uses ALRM itself and use the given signal insteadr. In this case, fork
# a child process to give the alternate signal when the timeout occurs.
sub call_with_timeout {
    my($desc,$fn,$args,$timeout,$verbose,$sigtouse)= @_;
    return undef unless defined($fn);
    $timeout= 60 unless defined $timeout;
    $verbose= 1 unless defined $verbose;
    $sigtouse= 'ALRM' unless defined $sigtouse;
    $output .= "---\n";
    print "call_with_timeout(",join(',',$desc,$fn,'['.join(',',@{$args}).']',$timeout,$verbose,$sigtouse),")\n" if $verbose > 3;

    my @res= ();
    my $start= time();
    my $timeoutpid= undef;

    eval {
        my $sighandler= sub {0 && print "pid $$: in signal handler for $_[0]\n";
                             $output .= "pid $$: $desc timed out with $_[0] after $timeout seconds";
                             die };
        $SIG{$sigtouse}= $sighandler;
        if ($sigtouse eq 'ALRM') {
            alarm($timeout);
        } else {
            my $fncallingpid= $$;
            $timeoutpid=fork();
            if ($timeoutpid == 0) {   # Child process
                exec($terminator,$sigtouse,$fncallingpid,$timeout,$verbose);
                die "(pid $fncallingpid) - could not exec $terminator\n";
            }
        }

        # Parent process
        # on timeout, alarm handler above will execute and we'll fall out of this eval
        # on normal exit, we'll fall out of the bottom of the eval with no error
        $output .= "$desc: starting call\n" if $verbose > 1;
        $output .= "&{$fn}(" . join(',',@{$args}) . ")\n" if $verbose > 1;
        @res = &{$fn}(join(',',@{$args}));  # Call the function
        $output .= "$desc exited normally: " . join(',',@res) . "\n" if $verbose > 4;
        $SIG{$sigtouse}= 'IGNORE';
        if ($sigtouse eq 'ALRM') {
            alarm(0);
        } else {
            $output .= "Verify ($$) finished in time; canceling terminator ($timeoutpid)\n" if $verbose > 2;
            kill 'KILL', $timeoutpid;
        }
    };

    my $elapsed= time()-$start;
    if ($@) {
        if ($@ =~ /timed out with/) { # we timed out
            $output .= "$@\n";
            return (0);
        } else { # the method call did a die
            # propagate
            $SIG{$sigtouse}= 'IGNORE';
            if ($sigtouse eq 'ALRM') {
                alarm(0);
            } else {
                kill $timeoutpid;
            }
            print "#### About to die. Failure trace:\n";
            print "$output\n";
            print "Contents of \$\@: $@\n";
            $logtime = gmtime();
            print "#### Terminated script (pid $$) at:   $logtime UTC\n";
            die;
        }
    }
    $output .= qq{$desc exited normally [elapsed=$elapsed]\n};
    return (1,@res);
}


sub end {
    $logtime = gmtime();
    $output .= "Ended script (pid $$) at:   $logtime UTC\n";
}


sub get_start_secs {
   my ($start,$end) = @_;

   my $num;

   # start is in the form of nw, nd, nh, nm, or ns where n stands for a
   # number, and w = weeks, d = days, h = hours, m = minutes and s = secs.
   if ( $start =~ m/(\d+) w/x ) {
      $num = $1;
      $num = $num * 7 * 24 * 3600;
   } elsif ( $start =~ m/(\d+) d/x ) {
      $num = $1;
      $num = $num * 24 * 3600;
   } elsif ( $start =~ m/(\d+) h/x ) {
      $num = $1;
      $num = $num * 3600;
   } elsif ( $start =~ m/(\d+) m/x ) {
      $num = $1;
      $num = $num * 60;
   } elsif ( $start =~ m/(\d+) s/x ) {
      $num = $1;
   } else {
      print "Bad entry: $start\n";
      exit(1);
   }

   return $end - $num;
}


sub set_start_time {
    my ($range, $offset, $end) = @_;

    my $rand  = int( rand($range));
    my $start = $end - $rand - $offset;

    return $start;
}


sub get_nodes {
    my ($test, $n) = @_;

    my %mon=();
    my @test_nodes=();
    my %test_ips = ();

    # Define filters
    my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
    $filters->time_start($start) if ( $start );
    # use bogus end time value on metadata as workaround to prevent racing condition
    # that may occur due to postgres time stamps at microsecond granularity, whereas
    # esmond time stamps are at the granularity of seconds.
    $filters->time_end(time + 86400) if ( $start );
    $filters->event_type("$test");

    # Connect to api
    my $encoded_host = uri_escape($ds);
    my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
        url => "http://$encoded_host:$port/esmond/perfsonar/archive",
        filters => $filters
    );
    end() if($client->error);
    croak ( "Central data store is not responding. No comparisons possible at this time. Cause:\n" . 
          $client->error ) if($client->error);

    # Get measurements matching filters
    my $md = $client->get_metadata();
    end() if($client->error);
    croak ( "Meta-data unavailable. No comparisons possible at this time. Cause:\n" .
          $client->error ) if($client->error);

    # Identify all unique monitor hosts
    foreach my $m ( @{$md} ) {
        my $mon = $m->measurement_agent();
        $mon{$mon} = 1;
    }

    my $total_nodes = scalar keys %mon;
    $n = $total_nodes if ( $n > $total_nodes ); # Ensure $n <= $total_nodes

    my %taken=();
    while ( scalar @test_nodes < $n ) {
        my $choice = (keys %mon)[rand keys %mon];
        next if ( $taken{$choice} );  # Prevent repeated selection of the same node
        $taken{$choice} = 1;
        # Obtain DNS name / IP
        my $node_name = $choice;
        my $node_ip = $$node_ip_ref{$node_name};
        push @test_nodes, $node_name;
        $test_ips{$node_name} = $node_ip;
    }

    return ("Selected test nodes ($n out of $total_nodes):",\@test_nodes,\%test_ips);
}


# gd logic changes with test type. Clean up logic if there is time
sub gd {
    my ($list) = @_;

    my ($test,$mon,$start,$end,$datastore,$port) = split(',',$list);

    my @results=();
    my $error=undef;

    # Now obtain data for each path with the retrieved monitoring hosts
    # Note: Use time_start() on metadata, time_end() on data
    my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
    $filters->time_start($start) if ( $start );     # Filters on metadata time_updated value
    # use bogus end time value on metadata as workaround to prevent racing condition
    # that may occur due to postgres time stamps at microsecond granularity, whereas
    # esmond time stamps are at the granularity of seconds.
    $filters->time_end(time + 86400) if ( $start );
    $filters->event_type($test);
    $filters->measurement_agent($mon);


        # Connect to api
        $date = gmtime();
        $output .= "[$date] Connect to api\n";
        my $encoded_host = uri_escape($datastore);
    
        my $clpath = new perfSONAR_PS::Client::Esmond::ApiConnect(
            url => "http://$encoded_host:$port/esmond/perfsonar/archive",
            filters => $filters
        );
        if($clpath->error) {
            $error = "Error - [$datastore] ($encoded_host) - " . $clpath->error;
            my @error=();
            push @error, $error;
            return @error;
        }

        # Get measurements matching filters
        $date = gmtime();
        $output .= "[$date] Get measurements matching filters for $mon\n";
        my $pd;
        $pd = $clpath->get_metadata();
        if($clpath->error) {
            $error = "Error - [$datastore] ($encoded_host) - " . $clpath->error;
            my @error=();
            push @error, $error;
            return @error;
        }
    
        print Dumper($pd) if ( $opt{debug} );
    
        foreach my $p ( @{$pd} ) {
            print Dumper($p) if ( $opt{debug} );
            # get data of a particular event type
            my $mon_ip = $p->measurement_agent();
            my $src_ip = $p->source();
            my $dst_ip = $p->destination();

            # When a mesh is specified, select only intra-mesh records
            next if ( $mesh_selection && !$mesh_ips{$src_ip} );
            next if ( $mesh_selection && !$mesh_ips{$dst_ip} );

            my $mk     = $p->metadata_key();
            my $et     = $p->get_event_type("$test");
            my $omk    = $p->get_field('org_metadata_key') || '';
            $et->filters->time_end($end);            # Add time_end filter on data
            my $data   = $et->get_data();
            if($et->error) {
                $error = "Error - [$datastore] ($encoded_host) - " . $et->error;
                my @error=();
                push @error, $error;
                return @error;
            }
            # get all data
            $date = gmtime();
            print "[$date] Get data\n" if ( $opt{debug} );
            if ( $test eq 'failures' ) {                               # failures
                foreach my $d ( @{$data} ) {
                    my $error_str = $d->val->{error};                  # error may contain new-line; chomp it
                    chomp $error_str;
                    my $rec = $d->ts . "," . $d->datetime . ",$mon_ip,$src_ip,$dst_ip," .
                              "'$error_str',$mk,$omk";
                    push @results, $rec;
                    print "$rec\n" if ( $opt{debug} );
                    #if ( $mon ne $datastore ) {  # Central
                    #    print "http:\/\/$encoded_host:$port\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                    #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                    #} else {                     # Remote
                    #    print "http:\/\/$mon\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                    #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                    #}
                }
            } elsif ( $test eq 'throughput' ||                         # throughput
                      $test eq 'packet-count-sent' ||                  # packet counts
                      $test eq 'packet-count-lost' ||
                      $test eq 'packet-loss-rate'  ||                  # packet-loss-rate
                      $test eq 'packet-retransmits' ) {                # packet-retransmits
                foreach my $d ( @{$data} ) {
                    my $rec = $d->ts . "," . $d->datetime . ",$mon_ip,$src_ip,$dst_ip," .
                              $d->val .
                              ",$mk,$omk";
                    push @results, $rec;
                    print "$rec\n" if ( $opt{debug} );
                    #if ( $mon ne $datastore ) {  # Central
                    #    print "http:\/\/$encoded_host:$port\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                    #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                    #} else {                     # Remote
                    #    print "http:\/\/$mon\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                    #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                    #}
                }
            } elsif ( $test eq 'histogram-owdelay'  ||
                      $test eq 'histogram-ttl' ) {                     # histogram data
                # get histogram statistics summary for base data
                my $stats_summ = $et->get_summary('statistics', 0);
                next unless($stats_summ);
                my $stats_data = $stats_summ->get_data();
                # error check
                if($stats_summ->error) {
                    $error = "Error - [$datastore] ($encoded_host) - " . $stats_summ->error;
                    my @error=();
                    push @error, $error;
                    return @error;
                }
                foreach my $stats_d ( @{$stats_data} ) {
                    my $rec = $stats_d->ts . "," . $stats_d->datetime . ",$mon_ip,$src_ip,$dst_ip," .
                              $stats_d->{val}->{median} .
                              ",$mk,$omk";
                    push @results, $rec;
                    print "$rec\n" if ( $opt{debug} );
                    #if ( $mon ne $datastore ) {  # Central
                    #    print "http:\/\/$encoded_host:$port\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                    #          $stats_d->ts . "\&time-end=" . $stats_d->ts . "\&format=json\n" if ( $opt{debug} );
                    #} else {                     # Remote
                    #    print "http:\/\/$mon\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                    #          $stats_d->ts . "\&time-end=" . $stats_d->ts . "\&format=json\n" if ( $opt{debug} );
                    #}
                }
            } elsif ( $test eq 'packet-trace' ) {                      # packet-trace
                ### TODO: Add error checking
                foreach my $d ( @{$data} ) {
                    foreach my $hop ( @{$d->val} ) {
                        my $error_message = ''; 
                        $error_message = $hop->{error_message} if ( defined $hop->{error_message} );
                        my $ip = '';
                        $ip = $hop->{ip} if ( defined $hop->{ip} );
                        my $mtu = '';
                        $mtu = $hop->{mtu} if ( defined $hop->{mtu} );
                        my $query = '';
                        $query = $hop->{query} if ( defined $hop->{query} );
                        my $rtt = '';
                        $rtt = $hop->{rtt} if ( defined $hop->{rtt} );
                        my $rec = $d->ts . "," . $d->datetime . ",$mon_ip,$src_ip,$dst_ip," .
                                  "'" . "$error_message;$ip;$mtu;$query;$rtt;" . $hop->{success} . ";" . $hop->{ttl} . "'" .
                                  ",$mk,$omk";
                        push @results, $rec;
                        print "$rec\n" if ( $opt{debug} );
                        #if ( $mon ne $datastore ) {  # Central
                        #    print "http:\/\/$encoded_host:$port\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                        #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                        #} else {                     # Remote
                        #    print "http:\/\/$mon\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                        #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                        #}
                    }
                }
            } elsif ( $test eq 'packet-retransmits-subintervals' ||
                      $test eq 'throughput-subintervals' ) {          # subinterval data
                ### TODO: Add error checking
                foreach my $d ( @{$data} ) {
                    foreach my $subint(@{$d->val}){
                        # Many in packet-retransmits-subintervals are NULL.
                        # To quiet warnings, set undefined values to ''.
                        # See https://github.com/perfsonar/regular-testing/issues/8
                        $subint->{val} = '' if ( !defined $subint->{val} );
                        my $rec = $d->ts . "," . $d->datetime . ",$mon_ip,$src_ip,$dst_ip," .
                                  "'" .$subint->{start} . ";" . $subint->{duration} . ";" . $subint->{val} . "'" .
                                  ",$mk,$omk";
                        push @results, $rec;
                        print "$rec\n" if ( $opt{debug} );
                        #if ( $mon ne $datastore ) {  # Central
                        #    print "http:\/\/$encoded_host:$port\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                        #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                        #} else {                     # Remote
                        #    print "http:\/\/$mon\/esmond\/perfsonar\/archive\/$mk\/$test\/base\?time-start=" .
                        #          $d->ts . "\&time-end=" . $d->ts . "\&format=json\n" if ( $opt{debug} );
                        #}
                    }
                }
            }
        }

    return @results;
}


sub parse_line {
    my ( $rec, $host ) = @_;

    # Comma-separated subparts
    my @r=split(',', $rec);
    my $count=1;
    foreach my $item (@r) {
        $count++;
    }
 
    # Constructing fields
 
    # Split the string and count how many comma-separated fields result.
    # Fields 0-4 go into $utc, $date, $mon, $src, and $dst, respectively.
    # The last field goes to $mk for remote sites. The remainder are then
    # concatenated as $val. There must be 7 fields altogether for remotes
    # and 8 fields for the central store ($mk->field 6; $omk->field 7).
 
    my $total_parts = scalar @r;
    my $utc  = $r[0];
    my $date = $r[1];
    my $mon  = $r[2];
    my $src  = $r[3];
    my $dst  = $r[4];
    my $val=undef;
    my $mk=undef;
    my $omk=undef;
    if ( $host eq 'central' ) {
        # case of central server
        # 8 fields
        # $omk is last field
        # $mk is next to last
        # total fields = 8;
        $mk  = $r[-2];
        $omk = $r[-1];
        $val = join(',',@r[5..$total_parts-3]);
    } else {
        # case of remote server
        # 7 fields
        # $mk is last field
        # total fields = 7;
        $mk  = $r[-1];
        $val = join(',',@r[5..$total_parts-2]);
    }

    return ( $utc,$date,$mon,$src,$dst,$val,$mk,$omk );
}


sub threewaycompare {
    my ($cref,$rref,$display,$prefix,$cshort) = @_;

    my %set1=();             # hash lookup table for $set1
    my %set2=();             # hash lookup table for $set2
    my %cmkey=();            # hash lookup table for metadata key for central
    my @not_in_set2=();      # keys in $set1 not found in $set2
    my @not_in_set1=();      # keys in $set2 not found in $set1
    my @diff_count=();       # Entries in both $set1 and $set2 with differing values
    my @same=();             # Entries in both $set1 and $set2 with identical values

    my @fields=();
    my $item;

    my $file_name=undef;
    my $dh=undef;
    if ( defined $prefix ) {
        $file_name = $prefix . '-' . $cshort . '-' . $now . '.diff';
        open($dh, '>', "$file_name");
    }

    # Sample record from the central store. Records from the remote sites have the same format, except the last field (omk)
    # is not present.
    # time      ,time               ,meas. agent ,src       ,dst         ,val       ,mk                              ,omk
    # 1432764947,2015-05-27T22:15:47,192.12.15.23,72.36.96.9,192.12.15.23,3005550000,0ddc0d3b12944be49ab5a8396e27a946,547fc3f735124dd8b3140871147f9c34
    # 0          1                   2            3          4            5          6                                7
    #
    # Want:
    # central $key -> [0..4][7]  because we need to use org_metadata_key [7] of central to match metadata-key [6] of remote
    # remote  $key -> [0..4][6]  because we need to use metadata-key [6] of remote to match org_metadata_key [7] of central
    # $value       -> [5]
    #
    # Note:
    # $value may be a comma-embedded string

    # Generate hash tables
    foreach my $i (@{$cref}) {
        my @fields = parse_line($i,'central');
        my $key = join(',', @fields[0..4]);
        $key .= ',' . $fields[7];
        my $value = $fields[5];
        $cmkey{$key} = $fields[6];
        $set1{$key} = $value;
    }

    foreach my $j (@{$rref}) {
        my @fields = parse_line($j,'remote');
        my $key = join(',', @fields[0..4]);
        $key .= ',' . $fields[6];
        my $value = $fields[5];
        $set2{$key} = $value;
    }

    # Comparing
    while ( my ($key, $val) = each(%set2) ) {
        if ( !defined($set1{$key}) || $set1{$key} eq '') {
            push (@not_in_set1, $key);
        } elsif ( $set1{$key} ne $val) {
            push (@diff_count, $key);
        } elsif ( $set1{$key} eq $val) {
            push (@same, $key);
        }
    }
    while ( my $key = each(%set1)) {
        if ( !defined($set2{$key}) || $set2{$key} eq '') {
            push (@not_in_set2, $key);
        }
    }



    # Display any discrepancies found

    print $dh "\n\nAlteration - Items in both the central store and the remote perfSONAR hosts where measures differ:\n" if ( defined $dh );
    $output .= "\n\nAlteration - Items in both the central store and the remote perfSONAR hosts where measures differ:\n";
    if (!@diff_count) {
        print $dh "          -- NONE --\n" if ( defined $dh );
        $output .= "          -- NONE --\n";
    } else {
        @diff_count = sort by_key @diff_count;
        foreach my $key (@diff_count) {
            print $dh "c: $key: $set1{$key} $cmkey{$key}\n" if ( defined $dh );
            print $dh "r: $key: $set2{$key}\n\n" if ( defined $dh );
            $output .= "c: $key: $set1{$key} $cmkey{$key}\n";
            $output .= "r: $key: $set2{$key}\n\n";
        }
    }

    if ( $display eq 'validate' || $display eq 'all' ) {
        print $dh "\nValidation - Items in the central store not in the remote perfSONAR hosts:\n" if ( defined $dh );
        $output .= "\nValidation - Items in the central store not in the remote perfSONAR hosts:\n";
        if (!@not_in_set2) {
            print $dh "          -- NONE --\n" if ( defined $dh );
            $output .= "          -- NONE --\n";
        } else {
            @not_in_set2 = sort by_key @not_in_set2;
            foreach my $key (@not_in_set2) {
                print $dh "c: $key: $set1{$key} $cmkey{$key}\n" if ( defined $dh );
                $output .= "c: $key: $set1{$key} $cmkey{$key}\n";
            }
        }
    }

    if ( $display eq 'cover' || $display eq 'all' ) {
        print $dh "\nCoverage   - Items in the remote perfSONAR hosts not in the central store:\n" if ( defined $dh );
        $output .= "\nCoverage   - Items in the remote perfSONAR hosts not in the central store:\n";
        if (!@not_in_set1) {
            print $dh "          -- NONE --\n" if ( defined $dh );
            $output .= "          -- NONE --\n";
        } else {
            @not_in_set1 = sort by_key @not_in_set1;
            foreach my $key (@not_in_set1) {
                print  $dh "r: $key: $set2{$key}\n" if ( defined $dh );
                $output .= "r: $key: $set2{$key}\n";
            }
        }
    }
}

sub by_key {
 ( $::a cmp $::b );
}


# This function returns UTC time elements given epoch seconds
sub sec2date {
    my $sec = shift;

    my ($seconds, $minutes, $hours, $dayOfMonth, $month, $year) = (gmtime $sec)[0,1,2,3,4,5];
    $month += 1;
    $year += 1900;

    return sprintf "%2.2d\/%2.2d\/%2.2d %2.2d:%2.2d:%2.2d",
                   $month, $dayOfMonth, $year, $hours, $minutes, $seconds;
}


# Parse input string MM/DD/YY[YY][,hh[:mm:ss]]
# Return UTC epoch seconds
sub date2sec {
    my $dateString = shift;

    my ($month, $mday, $year) = split('\/', $dateString);
    ($year, my $hr) = split(',', $year);
    ($hr, my $min, my $sec) = split(':', $hr);
    $hr  = 0 unless (defined $hr);
    $min = 0 unless (defined $min);
    $sec = 0 unless (defined $sec);
    if ( $year < 100 ) {                        # If 2-digit year given, add 2000.
       $year += 2000;
    }

    # Check that fields have valid values
    if ( $month !~ /\d+/ || $month < 1 || $month > 12 ) {
       print "Bad month entry. Try 1-12\n";
       exit(1);
    }
    if ( $mday !~ /\d+/ || $mday < 1 || $mday > 31 ) {
       print "Bad day of month entry. Try 1-31\n";
       exit(1);
    }
    if ( $year !~ /\d+/ || $year < 2015 ) {
       print "Bad year entry. Try 2015 up.\n";
       exit(1);
    }
    if ( $hr !~ /\d+/ || $hr < 0 || $hr > 23 ) {
       print "Bad hour entry. Try 0-23\n";
       exit(1);
    }
    if ( $min !~ /\d+/ || $min < 0 || $min > 59 ) {
       print "Bad minute entry. Try 0-59\n";
       exit(1);
    }
    if ( $sec !~ /\d+/ || $sec < 0 || $sec > 59 ) {
       print "Bad second entry. Try 0-59\n";
       exit(1);
    }

    # Pad fields with leading zero if needed
    $month = '0' . $month if ( length( $month ) == 1 );
    $mday  = '0' . $mday  if ( length( $mday )  == 1 );
    $hr    = '0' . $hr    if ( length( $hr )    == 1 );
    $min   = '0' . $min   if ( length( $min )   == 1 );
    $sec   = '0' . $sec   if ( length( $sec )   == 1 );

    return timegm( $sec, $min, $hr, $mday, $month - 1, $year - 1900 );
}


sub get_tests {
    my %test_menu = (  1  =>  "failure",
                       2  =>  "histogram-owdelay",
                       3  =>  "histogram-ttl",
                       4  =>  "packet-count-lost",
                       5  =>  "packet-count-sent",
                       6  =>  "packet-loss-rate",
                       7  =>  "packet-retransmits",
                       8  =>  "packet-retransmits-subintervals",
                       9  =>  "packet-trace",
                      10  =>  "throughput",
                      11  =>  "throughput-subintervals",
                    );

    print "Select one from the following list:\n";
    print "   Selection            Test\n";
    print "   ---------            -------\n";
    print "       1                failure\n";
    print "       2                histogram-owdelay\n";
    print "       3                histogram-ttl\n";
    print "       4                packet-count-lost\n";
    print "       5                packet-count-sent\n";
    print "       6                packet-loss-rate\n";
    print "       7                packet-retransmits\n";
    print "       8                packet-retransmits-subintervals\n";
    print "       9                packet-trace\n";
    print "      10                throughput\n";
    print "      11                throughput-subintervals\n";
    print "\n   =>  ";

    my $entry = <STDIN>;
    chomp $entry;
    if ( $entry =~ m/\d+/ &&
         $entry >= 1      &&
         $entry <= 11 ) {
       $test_selection = $test_menu{$entry};
    }
    else {
       print "Enter a number under 'Selection' to choose a test from the menu.\n";
       exit(1);
    }

    return $test_menu{$entry};
}


sub get_nodes_by_mesh {

    my %mm = ();

    # Obtain the mesh-node list
    if ( !(-f "$DATA/$MESHES") ) { # Update immediately if file not found
        open($fh, '>', "$DATA/$MESHES");
        `$Bin/update_meshes`;
        `$Bin/update_nodes`;
    }
    my $json = `cat $DATA/$MESHES`;
    my $pd = decode_json($json);
    foreach my $mesh_key (sort keys %{$pd}) {
        $mm{$mesh_key} = $pd->{$mesh_key}->{members};
    }
    return (\%mm);
}


sub mesh_menu {
    my $mesh_ref = shift;

    my $i=0;
    foreach my $mesh_key (sort keys %{$mesh_ref}) {
        $i++;
        $mesh_menu{$i} = $mesh_key;
    }
    print "Selection\tMesh Name\n";
    print "---------\t---------\n";
    foreach my $key (sort {$a <=> $b} keys %mesh_menu) {
        print "    $key\t\t=> $mesh_menu{$key}\n";
    }

    print "Enter a number under 'Selection' to choose a mesh from the menu:\n";
    my $entry = <STDIN>;
    chomp $entry;
    my $total_meshes = keys %mesh_menu;
    if ( $entry =~ m/\d+/ &&
         $entry >= 1      &&
         $entry <= $total_meshes ) {
        $mesh_selection = $mesh_menu{$entry};
    }
    else {
        print "Enter a number under 'Selection' to choose a mesh from the menu.\n";
        exit(1);
    }

    return $mesh_selection;
}


sub get_mesh_nodes {
    my ($mref,$test,$mesh,$n,$nodes,$start,$end) = @_;

    my %mon=();
    my @test_nodes=();
    my %test_ips=();
    my $desired_total_nodes=undef;

    # Get all nodes for the given mesh
    my $nref = $$mref{$mesh};
    foreach my $node ( @{$nref} ) {
        $mon{$node} = 1;
        my $mesh_node_name = $node;
        my $mesh_node_ip = $$node_ip_ref{$mesh_node_name};
        $mesh_ips{$mesh_node_ip} = 1;
    }
    my $total_nodes = scalar keys %mon;

    # Was a desired number of nodes or a node list provided?
    if ( $nodes ) {  # node list provided
        @test_nodes = split(',', $nodes);
        $desired_total_nodes = scalar (@test_nodes);
        # Comfirm each one is a member of the mesh, else reject it
        # Rejection will cause a drop from the desired total nodes
        my @confirmed_nodes=();
        foreach my $node ( @test_nodes ) {
            if ( $mon{$node} ) {
                push @confirmed_nodes, $node;
            }
        } 
        @test_nodes = @confirmed_nodes;
        $node_list = join( ',', @test_nodes );
    } elsif ( $n ) { # node number provided
        $desired_total_nodes = $opt{n};
    }

    foreach my $node (@test_nodes) {
        # Obtain DNS name / IP
        my $node_name = $node;
        my $node_ip = $$node_ip_ref{$node_name};
        $test_ips{$node_name} = $node_ip;
    }

    # Ensure the number of selected nodes <= total nodes
    $desired_total_nodes = $total_nodes if ( $desired_total_nodes > $total_nodes );

    # If a list of nodes was not (fully) provided, add more
    my %taken=();
    while ( scalar @test_nodes < $desired_total_nodes ) {
        my $choice = (keys %mon)[rand keys %mon];
        next if ( $taken{$choice} );  # Prevent repeated selection of the same node
        $taken{$choice} = 1;
        # Obtain DNS name / IP
        my $node_name = $choice;
        my $node_ip = $$node_ip_ref{$node_name};
        push @test_nodes, $node_name;
        $test_ips{$node_name} = $node_ip;
    }

    return ("Selected test nodes ($desired_total_nodes out of $total_nodes)",\@test_nodes,\%test_ips);
}


sub get_node_ips {
    my $file_name = shift;

    my %node_ip=();
    my $fh;
    open( $fh, '<', $file_name ) or die "(pid $$) - Could not open the nodes file '$file_name'.\n";

    while( <$fh> ) {
        chomp $_;
        my ($name, $ip) = split(',', $_);
        $node_ip{$name} = $ip;
    }

    return \%node_ip;
}



sub gen_links {
    my ($str_ref,$test_selection,$ds_short,$ds,$port) = @_;

    my @f    = ();
    my $time = undef;
    my $mon  = undef;
    my $mk   = undef;
    my $uri  = undef;
    my $cmk  = undef;
    my $encoded_mon = undef;
    my $central = $ds . ':' . $port;

    my $lh=undef;
    my $log_file=undef;
    if ( $opt{split_logs} ) {
        $log_file = $LOGS . '/' . $test_selection . '_' . $ds_short . '_' . $Script . '.log';
        open($lh, '>>', $log_file) or die "Could not open file '$log_file' $!";
    } else {
        $lh = *STDOUT;   # typeglob
    }

    my @lines = split('\n', $$str_ref);
    my $line=undef;

    while ( scalar (@lines) > 0 ) {
        $line = shift @lines;
        if ( $line =~ m/Started/ ) {
            print {*$lh} "_" x120;
            print {*$lh} "\n\n$line\n";
            $line = shift @lines;
            print {*$lh} "$line\n";
            $line = shift @lines;
            print {*$lh} "$line\n";
            $line = shift @lines;
            print {*$lh} "$line\n";
            $line = shift @lines;
            print {*$lh} "$line\n";
            $line = shift @lines;
            print {*$lh} "$line\n";
        }
        if ( $line =~ m/verify/ ) {
            print {*$lh} "\n$line\n";
            while ( scalar (@lines) > 0 ) {
                $line = shift @lines;
                if ( $line =~ m/rejected/ ) {
                    print {*$lh} "\n$line\n";
                    $line = shift @lines;
                    print {*$lh} "$line\n";
                }
                if ( $line =~ m/Comparing/ ) {
                    my $past_Validation = 0;
                    print {*$lh} "\n$line\n";
                    while ( scalar (@lines) > 0 ) {
                        $line = shift @lines;
                        if ( $line !~ m/Ended script/ ) {
                            $past_Validation = 1 if ( $line =~ m/Validation/ );
                            print {*$lh} "$line\n" if ( $line !~ m/^c:/ && $line !~ m/^r:/ );
                            if ( $line =~ m/^r:/ ) {
                                @f = split(' ', $line);
                                @f = split(',', $f[1]);
                                $time = $f[0];
                                $mon = $f[2];
                                $encoded_mon = uri_escape($mon);
                                $mk = $f[5];
                                chop $mk;        # remove ending colon
                                $uri="http://$encoded_mon/esmond/perfsonar/archive/$mk/$test_selection/base\?time-start=$time\&time-end=$time\&format=json";
                                print {*$lh} "$uri\n";
                                print {*$lh} "\n" if ( !$past_Validation );
                            }
                            if ( $line =~ m/^c:/ ) {
                                @f = split(' ', $line);
                                $cmk = $f[3];
                                @f = split(',', $f[1]);
                                $time = $f[0];
                                $mon = $f[2];
                                $encoded_mon = uri_escape($mon);
                                $uri="http://$central/esmond/perfsonar/archive/$cmk/$test_selection/base\?time-start=$time\&time-end=$time\&format=json";
                                print {*$lh} "$uri\n";
                            }
                        } else {
                            print {*$lh} "$line\n";
                            last;
                        }
                    }
                  last if ( $line =~ m/Ended script/ );
                }
            }
        }
    }
}


sub help {
    print <<EOF;

    Verify is a Perl script that compares perfSONAR data in remote perfSONAR hosts to the same data collected in
    centralized data stores. Its purpose is to confirm that the data centralization process is complete and accurate.
    
    Comparisons Performed  
    1) Alteration - This checks for items in both the central store and the remote perfSONAR hosts where values differ.  
    2) Validation - This checks for items in the central store that are not in the remote perfSONAR hosts.  
    3) Coverage - This checks for items in the remote perfSONAR hosts that are not in the central store.
    
    Typically, the script will be executed from cron, specifying a central repository to test with, a mesh and/or test
    type to use, and the number of perfSONAR hosts to include in the test. The script will select the hosts, start, and
    end times at "random", perform the tests, and return results. It is also possible to specify the perfSONAR hosts to test
    against, along with start and end times. This is helpful when interested in repeating the same test.
    
    Options
    --central    - Comma-separated string. The host name or IP address of one or more central repositories, each optionally
                   followed by a colon (:) and a port number. Default port number is 80. Alternatively, use 'all' to select
                   all central repositories, in which case the host names and ports are obtained from the configuration file.
    --mesh       - String. The mesh to use  
    --mesh_menu  - Integer. Allows selection of a mesh from a list. Helpful when the mesh name is not known. 
    --test       - String. The test type to select. Available types are:
                   failures, histogram-owdelay, histogram-ttl, packet-count-lost, packet-count-sent, packet-loss-rate,
                   packet-retransmits, packet-retransmits-subintervals, packet-trace, throughput, throughput-subinterval
    --test_menu  - Integer. Allows selection of a test type from a list. Helpful when the test name is not known.
    --n          - Integer. The number of perfSONAR nodes to select for testing. Ignored when --nodes is used.
    --nodes      - Optional. A comma-separated list of perfSONAR host names or IP addresses to test with
                   (if specific nodes are desired)
    --start      - Optional integer. Select records with a UTC epoch seconds time stamp >= this value
    --end        - Optional integer. Select records with a UTC epoch seconds time stamp <= this value
    --start_date - Optional. Like start but uses a UTC date string with format [M]M/[D]D/YY[YY][,[h]h[:[m]m[:[s]s]]]
    --end_date   - Optional. Like end but uses a UTC date string with format [M]M/[D]D/YY[YY][,[h]h[:[m]m[:[s]s]]]
    --last       - Optional. Designates the last so many time units as the start time. End time is "now".
                   Possible values are in the form of nw, nd, nh, nm, or ns, where n is a positive integer and
                   w = weeks, d = days, h = hours, m = minutes, s = secs.
    --delay      - Optional. Skip records with time stamps more recent than this many seconds ago. Default value is
                   stored in the conf file. This gives time for the central store to sync up with remote stores and
                   reduce false positives. It is ignored when start/end parameters are specified. It is referenced
                   otherwise.
    --display    - Optional string. Select test results to display. Default action is to show all tests
                   (either by not using it or with --display all)
                   --display validate => show alteration and validation
                   --display coverage => show alteration and coverage
    --out        - Optional path and file name prefix for collected data used in generating the log. Remote data is written to
                   "path/prefix-[timestamp].remote"; the other file names take the format "path/prefix-[host]-[timestamp].[source]".
                   The central store short name goes in [host], [timestamp] refers to the UNIX time the script ran and [source] is
                   "central" for the central store, or "diff" for the remote/central comparison.
    --split_logs - Optional. The $Script script generally outputs results to STDOUT. Use this option when it is desired to output
                   results to different log files, each corresponding to a central store identified in the --central option.
    --update     - Optional. Mesh, node, and IP address information is updated regularly by update scripts in this repository.
                   This option forces an update to occur prior to running $Script. Note: The update may take a few minutes to
                   complete and is meant to be used sparingly.
    --help       - Displays this information
 
    Sample Usage  
    - Compare pack-count-sent data between the central store (psds1.grid.iu.edu) and two script-selected perfSONAR hosts
      that collect pack-count-sent data for a script-selected time range. Output results to STDOUT.  
      $Script --central psds1.grid.iu.edu --test packet-count-sent --n 2
    
    - Compare packet-loss-rate data between the central data store and one script-selected host, returning only alteration
      and validation differences; i.e., ignoring coverage test results to STDOUT.  
      $Script --test packet-loss-rate --central psds2.grid.iu.edu --n 1 --display validate
    
    - Compare packet-count-sent data from the central repository, using port 9090, with data from two specified hosts for
      the specified time range  
      $Script --central fermicloud171.fnal.gov:9090 --test packet-count-sent \
             --nodes sonar2.itim-cj.ro,perfsonar01.cmsaf.mit.edu --start 1434800261 --end 1434875281
    
    - Request a comparison with specific perfSONAR hosts in a given mesh for a specified time range  
      $Script --central fermicloud171.fnal.gov:9090 --mesh 'USATLAS Bandwidth Mesh Test' --test throughput-subintervals \
             --nodes psum02.aglt2.org,ps2.ochep.ou.edu --start_date 09/12/2015,05:29:28 --end_date 09/12/2015,10:52:01
   
    - Compare throughput data between all central stores (identified it the config file) and four script-selected perfSONAR
      hosts which collect throughput data in the given mesh for a script-selected time range. Store raw data in files with
      prefix ../logs/vtest and output final results to separate throughput log files, according to the selected central stores.
      $Script -central all --mesh 'USATLAS Bandwidth Mesh Test' --test throughput -n 4 --out ../logs/vtest --split_logs
   
    - Compare failures data between two specified central hosts and three script-selected perfSONAR hosts which collect failures
      data in the given mesh for a script-selected time range. Output results to STDOUT.
      $Script -central fermicloud171.fnal.gov:9090,psds1.grid.iu.edu --mesh 'USATLAS Bandwidth Mesh Test' --test throughput -n 3
    
    - Allow user to select a test type and mesh from option lists  
      $Script --central fermicloud171.fnal.gov:9090 --mesh_menu --test_menu -n 2
   
    $Script version $VERSION
   
EOF
}
